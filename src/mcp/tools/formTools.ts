// formTools.ts
// Tools for managing forms (objectWorkflow) via MCP
// Created on: October 25, 2025
// This file implements form tools for the MCP server

/**
 * Implements form tools for the MCP server
 */
export class FormTools {
    constructor(modelService: any) {
        // ModelService passed but not used - MCP server uses HTTP bridge
    }

    /**
     * Gets the schema definition for forms (objectWorkflow)
     * Tool name: get_form_schema (following MCP snake_case convention)
     * @returns Schema definition with properties, validation rules, and examples for forms
     */
    public async get_form_schema(): Promise<any> {
        return {
            success: true,
            schema: {
                type: 'object',
                description: 'Form (objectWorkflow) structure in AppDNA model - represents user interface forms for data entry, editing, and deletion',
                objectType: 'objectWorkflow',
                properties: {
                    name: {
                        type: 'string',
                        required: true,
                        format: 'PascalCase',
                        pattern: '^[A-Z][A-Za-z0-9]*$',
                        description: 'Workflow ID, unique for each workflow element. Must be in PascalCase format (starts with uppercase letter, no spaces, can contain letters and numbers).',
                        examples: ['AddCustomer', 'UpdateOrder', 'DeleteProduct', 'ViewCustomerDetails', 'CustomerRegistration']
                    },
                    titleText: {
                        type: 'string',
                        required: false,
                        description: 'Title displayed on the form page. Human-readable title for the form UI.',
                        examples: ['Add Customer', 'Update Order', 'Delete Product', 'View Customer Details']
                    },
                    initObjectWorkflowName: {
                        type: 'string',
                        required: false,
                        description: 'Workflow name for initialization flow (e.g., "UpdateFlavorInitObjWF"). Used for page init flows .cs file names.',
                        examples: ['UpdateFlavorInitObjWF', 'AddCustomerInitObjWF', 'CustomerListInitObjWF']
                    },
                    isInitObjWFSubscribedToParams: {
                        type: 'string',
                        required: false,
                        enum: ['true', 'false'],
                        description: 'Are the init obj wf output vars auto generated by the params of this form? String "true" or "false".',
                        examples: ['true', 'false']
                    },
                    isObjectDelete: {
                        type: 'string',
                        required: false,
                        enum: ['true', 'false'],
                        description: 'Is this form deleting the owner object? If true, this is a delete operation form.',
                        examples: ['true', 'false']
                    },
                    layoutName: {
                        type: 'string',
                        required: false,
                        description: 'Name of the layout template to use for this form.',
                        examples: ['DefaultLayout', 'TwoColumnLayout', 'WideLayout']
                    },
                    introText: {
                        type: 'string',
                        required: false,
                        description: 'Introduction text displayed at the top of the form.',
                        examples: ['Please enter customer details below.', 'Update the order information.']
                    },
                    formTitleText: {
                        type: 'string',
                        required: false,
                        description: 'Form-specific title text (alternative to titleText).',
                        examples: ['Customer Registration Form', 'Order Details']
                    },
                    formIntroText: {
                        type: 'string',
                        required: false,
                        description: 'Form-specific introduction text.',
                        examples: ['Fill out the information below to create a new customer account.']
                    },
                    formFooterText: {
                        type: 'string',
                        required: false,
                        description: 'Text displayed in the form footer.',
                        examples: ['© 2025 Company Name', 'Contact support at support@company.com']
                    },
                    codeDescription: {
                        type: 'string',
                        required: false,
                        description: 'Code description for documentation and code generation hints.',
                        examples: ['Add customer workflow', 'Update order details', 'Delete product entry']
                    },
                    isAutoSubmit: {
                        type: 'string',
                        required: false,
                        enum: ['true', 'false'],
                        description: 'Should the form auto-submit when conditions are met? String "true" or "false".',
                        examples: ['true', 'false']
                    },
                    isHeaderVisible: {
                        type: 'string',
                        required: false,
                        enum: ['true', 'false'],
                        description: 'Is the form header visible? String "true" or "false".',
                        examples: ['true', 'false']
                    },
                    isPage: {
                        type: 'string',
                        required: false,
                        enum: ['', 'true', 'false'],
                        description: 'Is this a standalone page? Can be empty string, "true", or "false".',
                        examples: ['', 'true', 'false']
                    },
                    isAuthorizationRequired: {
                        type: 'string',
                        required: false,
                        enum: ['true', 'false'],
                        description: 'Does this form require user authorization? String "true" or "false".',
                        examples: ['true', 'false']
                    },
                    isLoginPage: {
                        type: 'string',
                        required: false,
                        enum: ['true', 'false'],
                        description: 'Is this the login page? String "true" or "false".',
                        examples: ['true', 'false']
                    },
                    isLogoutPage: {
                        type: 'string',
                        required: false,
                        enum: ['true', 'false'],
                        description: 'Is this the logout page? String "true" or "false".',
                        examples: ['true', 'false']
                    },
                    roleRequired: {
                        type: 'string',
                        required: false,
                        description: 'Name of the role required to access this form. Should match a role name from the Role lookup object.',
                        examples: ['Administrator', 'Manager', 'User', 'DataEntryClerk']
                    },
                    isCaptchaVisible: {
                        type: 'string',
                        required: false,
                        enum: ['true', 'false'],
                        description: 'Should a CAPTCHA be displayed on this form? String "true" or "false".',
                        examples: ['true', 'false']
                    },
                    targetChildObject: {
                        type: 'string',
                        required: false,
                        description: 'Child object of the owner object that is being added/edited/deleted by this form. Must match an existing data object name (case-sensitive).',
                        examples: ['Order', 'OrderLineItem', 'Customer', 'Product']
                    },
                    isCustomLogicOverwritten: {
                        type: 'string',
                        required: false,
                        enum: ['true', 'false'],
                        description: 'Is custom logic overwritten for this form? String "true" or "false".',
                        examples: ['true', 'false']
                    },
                    objectWorkflowParam: {
                        type: 'array',
                        required: false,
                        description: 'Array of input control parameters (form fields) for this form. Each parameter represents a field/input control on the form.',
                        items: {
                            type: 'object',
                            properties: {
                                name: {
                                    type: 'string',
                                    required: true,
                                    format: 'PascalCase',
                                    description: 'Object workflow parameter name in PascalCase format',
                                    examples: ['FirstName', 'LastName', 'EmailAddress', 'CustomerID', 'IsActive']
                                },
                                sqlServerDBDataType: {
                                    type: 'string',
                                    required: false,
                                    enum: ['nvarchar', 'bit', 'datetime', 'int', 'uniqueidentifier', 'money', 'bigint', 'float', 'decimal', 'date', 'varchar', 'text'],
                                    description: 'SQL Server data type for this parameter',
                                    examples: ['nvarchar', 'bit', 'datetime', 'int', 'uniqueidentifier']
                                },
                                sqlServerDBDataTypeSize: {
                                    type: 'string',
                                    required: false,
                                    description: 'Size of data type (for nvarchar, varchar, decimal). Default is 100 for nvarchar.',
                                    examples: ['50', '100', '255', 'MAX', '18,2']
                                },
                                labelText: {
                                    type: 'string',
                                    required: false,
                                    description: 'Human-readable label text displayed for this field',
                                    examples: ['First Name', 'Last Name', 'Email Address', 'Customer ID']
                                },
                                infoToolTipText: {
                                    type: 'string',
                                    required: false,
                                    description: 'Tooltip text displayed when hovering over the info icon next to the parameter label',
                                    examples: ['Enter your first name', 'This field is required']
                                },
                                codeDescription: {
                                    type: 'string',
                                    required: false,
                                    description: 'Code description for documentation',
                                    examples: ['Customer first name field']
                                },
                                defaultValue: {
                                    type: 'string',
                                    required: false,
                                    description: 'Default value for this parameter',
                                    examples: ['0', 'false', '']
                                },
                                isVisible: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is this parameter visible on the form? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isRequired: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is this parameter required? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                requiredErrorText: {
                                    type: 'string',
                                    required: false,
                                    description: 'Error message displayed when required field is not filled',
                                    examples: ['First name is required', 'Please enter your email address']
                                },
                                isSecured: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should this parameter be secured (password field)? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isFK: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is this parameter a foreign key? String "true" or "false". If true, provide fKObjectName.',
                                    examples: ['true', 'false']
                                },
                                fKObjectName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of the foreign key object target (data object name). Case-sensitive.',
                                    examples: ['Customer', 'Order', 'Status', 'Role']
                                },
                                fKObjectQueryName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of the foreign key object query',
                                    examples: ['GetCustomerList', 'GetOrderList']
                                },
                                isFKLookup: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is this parameter a foreign key to a lookup object? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isFKList: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should a dropdown list be shown for this FK? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isFKListInactiveIncluded: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should inactive items be included in the FK dropdown list? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isFKListUnknownOptionRemoved: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should the "Unknown" option be removed from FK dropdown? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                fKListOrderBy: {
                                    type: 'string',
                                    required: false,
                                    enum: ['NameDesc', 'NameAsc', 'DisplayOrderDesc', 'DisplayOrderAsc'],
                                    description: 'Sort order for FK dropdown list',
                                    examples: ['NameAsc', 'NameDesc', 'DisplayOrderAsc']
                                },
                                isFKListOptionRecommended: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should a recommended option be highlighted in FK dropdown? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isFKListSearchable: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should the FK dropdown list be searchable? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                FKListRecommendedOption: {
                                    type: 'string',
                                    required: false,
                                    description: 'The recommended option value for FK dropdown',
                                    examples: ['Active', 'Default', 'Recommended']
                                },
                                isRadioButtonList: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should this parameter be displayed as radio buttons? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isFileUpload: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is this parameter a file upload field? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isCreditCardEntry: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is this parameter a credit card entry field? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isTimeZoneDetermined: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should timezone be determined for this parameter? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isAutoCompleteAddressSource: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Implements typical Google address autocomplete. String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                autoCompleteAddressSourceName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of the source parameter for address autocomplete. Source should have isAutoCompleteAddressSource set to true.',
                                    examples: ['Address', 'AddressLine1']
                                },
                                autoCompleteAddressTargetType: {
                                    type: 'string',
                                    required: false,
                                    enum: ['AddressLine1', 'AddressLine2', 'City', 'StateAbbrev', 'Zip', 'Country', 'Latitude', 'Longitude'],
                                    description: 'Type of address field this parameter represents for autocomplete',
                                    examples: ['AddressLine1', 'City', 'StateAbbrev', 'Zip']
                                },
                                detailsText: {
                                    type: 'string',
                                    required: false,
                                    description: 'Additional details text for this parameter',
                                    examples: ['Additional information about this field']
                                },
                                validationRuleRegExMatchRequired: {
                                    type: 'string',
                                    required: false,
                                    description: 'Regular expression pattern that this parameter must match',
                                    examples: ['^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$', '^\\d{3}-\\d{3}-\\d{4}$']
                                },
                                validationRuleRegExMatchRequiredErrorText: {
                                    type: 'string',
                                    required: false,
                                    description: 'Error message displayed when regex validation fails',
                                    examples: ['Invalid email format', 'Invalid phone number format']
                                },
                                isIgnored: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should this parameter be ignored by the code generator? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                sourceObjectName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of the source data object for this parameter',
                                    examples: ['Customer', 'Order', 'Product']
                                },
                                sourcePropertyName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of the source property from the source object',
                                    examples: ['FirstName', 'LastName', 'EmailAddress']
                                }
                            }
                        },
                        examples: [
                            [
                                {
                                    name: 'FirstName',
                                    sqlServerDBDataType: 'nvarchar',
                                    sqlServerDBDataTypeSize: '100',
                                    labelText: 'First Name',
                                    isVisible: 'true',
                                    isRequired: 'true',
                                    requiredErrorText: 'First name is required'
                                },
                                {
                                    name: 'CustomerID',
                                    sqlServerDBDataType: 'int',
                                    labelText: 'Customer',
                                    isVisible: 'true',
                                    isFK: 'true',
                                    fKObjectName: 'Customer',
                                    isFKList: 'true',
                                    isFKListSearchable: 'true'
                                },
                                {
                                    name: 'StatusID',
                                    sqlServerDBDataType: 'int',
                                    labelText: 'Status',
                                    isVisible: 'true',
                                    isFK: 'true',
                                    isFKLookup: 'true',
                                    fKObjectName: 'Status',
                                    isFKList: 'true'
                                }
                            ]
                        ]
                    },
                    objectWorkflowButton: {
                        type: 'array',
                        required: false,
                        description: 'Array of buttons displayed on the form. Each button represents an action the user can take.',
                        items: {
                            type: 'object',
                            properties: {
                                buttonType: {
                                    type: 'string',
                                    required: false,
                                    description: 'Type of button (submit, cancel, back, other, etc.)',
                                    examples: ['submit', 'cancel', 'back', 'other']
                                },
                                buttonText: {
                                    type: 'string',
                                    required: false,
                                    description: 'Text displayed on the button',
                                    examples: ['Submit', 'Cancel', 'Save', 'Back', 'Delete']
                                },
                                isVisible: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is this button visible? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                conditionalVisiblePropertyName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of property that controls button visibility conditionally',
                                    examples: ['IsEditMode', 'CanDelete']
                                },
                                destinationContextObjectName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of the data object that owns the destination target',
                                    examples: ['Customer', 'Order']
                                },
                                destinationTargetName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of the destination form/report/workflow to navigate to when button is clicked',
                                    examples: ['CustomerList', 'UpdateCustomer', 'OrderDetails']
                                },
                                introText: {
                                    type: 'string',
                                    required: false,
                                    description: 'Introduction text for the button',
                                    examples: ['Click to submit the form', 'Click to cancel']
                                },
                                isButtonCallToAction: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should this button be displayed as a call-to-action (highlighted)? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                accessKey: {
                                    type: 'string',
                                    required: false,
                                    description: 'Keyboard access key for the button',
                                    examples: ['s', 'c', 'b']
                                },
                                isAccessKeyAvailable: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is keyboard access key available for this button? String "true" or "false".',
                                    examples: ['true', 'false']
                                }
                            }
                        },
                        examples: [
                            [
                                {
                                    buttonType: 'submit',
                                    buttonText: 'Submit',
                                    isVisible: 'true',
                                    isButtonCallToAction: 'true'
                                },
                                {
                                    buttonType: 'cancel',
                                    buttonText: 'Cancel',
                                    isVisible: 'true',
                                    destinationContextObjectName: 'Customer',
                                    destinationTargetName: 'CustomerList'
                                }
                            ]
                        ]
                    },
                    objectWorkflowOutputVar: {
                        type: 'array',
                        required: false,
                        description: 'Array of output variables displayed after form submission. Each output variable represents a result value shown to the user.',
                        items: {
                            type: 'object',
                            properties: {
                                name: {
                                    type: 'string',
                                    required: true,
                                    format: 'PascalCase',
                                    description: 'Output variable name in PascalCase format',
                                    examples: ['SuccessMessage', 'ErrorMessage', 'CustomerID', 'OrderNumber']
                                },
                                sqlServerDBDataType: {
                                    type: 'string',
                                    required: false,
                                    enum: ['nvarchar', 'bit', 'datetime', 'int', 'uniqueidentifier', 'money', 'bigint', 'float', 'decimal', 'date', 'varchar', 'text'],
                                    description: 'SQL Server data type for this output variable',
                                    examples: ['nvarchar', 'int', 'bit']
                                },
                                sqlServerDBDataTypeSize: {
                                    type: 'string',
                                    required: false,
                                    description: 'Size of data type (for nvarchar, varchar, decimal)',
                                    examples: ['100', '255', 'MAX']
                                },
                                labelText: {
                                    type: 'string',
                                    required: false,
                                    description: 'Label text displayed for this output variable',
                                    examples: ['Success Message', 'Customer ID', 'Order Number']
                                },
                                buttonText: {
                                    type: 'string',
                                    required: false,
                                    description: 'Text displayed on button if output variable is a button',
                                    examples: ['View Customer', 'View Order', 'Continue']
                                },
                                buttonNavURL: {
                                    type: 'string',
                                    required: false,
                                    description: 'Navigation URL for button output variable',
                                    examples: ['/customer/details', '/order/list']
                                },
                                isLabelVisible: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is the label visible for this output variable? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                defaultValue: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Default value for this output variable. String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isLink: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is this output variable a link? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isAutoRedirectURL: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should the form auto-redirect to this URL? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                buttonObjectWFName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of the workflow to navigate to when button is clicked',
                                    examples: ['ViewCustomer', 'UpdateOrder']
                                },
                                conditionalVisiblePropertyName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of property that controls output variable visibility conditionally',
                                    examples: ['IsSuccess', 'HasError']
                                },
                                isVisible: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is this output variable visible? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isFK: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is this output variable a foreign key? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                fKObjectName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of the foreign key object target',
                                    examples: ['Customer', 'Order']
                                },
                                isFKLookup: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Is this output variable a foreign key to a lookup object? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isHeaderText: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should this output variable be displayed as header text? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                isIgnored: {
                                    type: 'string',
                                    required: false,
                                    enum: ['true', 'false'],
                                    description: 'Should this output variable be ignored by the code generator? String "true" or "false".',
                                    examples: ['true', 'false']
                                },
                                sourceObjectName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of the source data object for this output variable',
                                    examples: ['Customer', 'Order']
                                },
                                sourcePropertyName: {
                                    type: 'string',
                                    required: false,
                                    description: 'Name of the source property from the source object',
                                    examples: ['CustomerID', 'OrderNumber']
                                }
                            }
                        },
                        examples: [
                            [
                                {
                                    name: 'SuccessMessage',
                                    sqlServerDBDataType: 'nvarchar',
                                    sqlServerDBDataTypeSize: '255',
                                    labelText: 'Success Message',
                                    isVisible: 'true',
                                    isHeaderText: 'true'
                                },
                                {
                                    name: 'CustomerID',
                                    sqlServerDBDataType: 'int',
                                    labelText: 'Customer ID',
                                    isVisible: 'true',
                                    buttonText: 'View Customer',
                                    isLink: 'true'
                                }
                            ]
                        ]
                    }
                },
                validationRules: {
                    name: [
                        'Required field',
                        'Must be unique within the object\'s objectWorkflow array (case-insensitive check)',
                        'Must be in PascalCase format',
                        'Must start with uppercase letter',
                        'Can only contain letters (A-Z, a-z) and numbers (0-9)',
                        'No spaces, hyphens, or special characters allowed',
                        'Common patterns: Action + Entity (AddCustomer, UpdateOrder, DeleteProduct, ViewDetails)'
                    ],
                    titleText: [
                        'Optional field',
                        'Human-readable title for the form',
                        'Displayed at the top of the form page',
                        'Can contain spaces and special characters'
                    ],
                    targetChildObject: [
                        'Optional field',
                        'Must match an existing data object name exactly (case-sensitive)',
                        'Defines which child object this form operates on',
                        'Common for Add/Update/Delete forms'
                    ],
                    roleRequired: [
                        'Optional field',
                        'Must match a role name from the Role lookup object (case-sensitive)',
                        'Controls who can access this form',
                        'Leave empty for public access',
                        'Common values: Administrator, Manager, User, DataEntryClerk'
                    ],
                    objectWorkflowParam: [
                        'Optional array - only included if form has input controls',
                        'Each parameter must have unique name within the form',
                        'Parameter names must be in PascalCase format',
                        'All boolean-like fields use string "true"/"false" not boolean',
                        'sqlServerDBDataType must be one of: nvarchar, bit, datetime, int, uniqueidentifier, money, bigint, float, decimal, date, varchar, text',
                        'sqlServerDBDataTypeSize required for nvarchar, varchar, decimal types',
                        'isFK must be "true" or "false" - if "true" then fKObjectName is required',
                        'isFKLookup must be "true" or "false" - indicates FK to a lookup object',
                        'isFKList must be "true" or "false" - shows dropdown for FK selection',
                        'isVisible must be "true" or "false" - controls field visibility',
                        'isRequired must be "true" or "false" - controls field validation',
                        'fKObjectName must match existing data object name exactly (case-sensitive)',
                        'sourceObjectName and sourcePropertyName link to data object properties'
                    ],
                    objectWorkflowButton: [
                        'Optional array - only included if form has buttons',
                        'Common button types: submit, cancel, back, other',
                        'buttonText provides the displayed text on the button',
                        'destinationContextObjectName and destinationTargetName define navigation',
                        'isButtonCallToAction highlights the button as primary action',
                        'All boolean-like fields use string "true"/"false" not boolean'
                    ],
                    objectWorkflowOutputVar: [
                        'Optional array - only included if form has output variables',
                        'Each output variable must have unique name within the form',
                        'Output variable names must be in PascalCase format',
                        'Can be text displays, links, or buttons',
                        'isLink="true" makes the output variable clickable',
                        'isHeaderText="true" displays as prominent header text',
                        'All boolean-like fields use string "true"/"false" not boolean'
                    ]
                },
                usage: {
                    location: 'Stored in namespace → object → objectWorkflow array in AppDNA model',
                    access: 'Via namespace[0].object[n].objectWorkflow array',
                    modelStructure: 'namespace → object[] → objectWorkflow[]',
                    purpose: 'Define forms for data entry, editing, and deletion operations',
                    relatedTools: [
                        'list_forms - List all forms from the model (if implemented)',
                        'get_form - Get a specific form by name (if implemented)',
                        'create_form - Create new form (if implemented)',
                        'open_form_details_view - Open form details editor in VS Code',
                        'open_add_form_wizard - Open wizard for creating new forms'
                    ]
                },
                commonPatterns: {
                    addForm: {
                        name: 'AddCustomer',
                        titleText: 'Add Customer',
                        targetChildObject: 'Customer',
                        isAuthorizationRequired: 'true',
                        roleRequired: 'DataEntryClerk',
                        objectWorkflowParam: [
                            {
                                name: 'FirstName',
                                sqlServerDBDataType: 'nvarchar',
                                sqlServerDBDataTypeSize: '100',
                                labelText: 'First Name',
                                isVisible: 'true',
                                isRequired: 'true'
                            }
                        ],
                        objectWorkflowButton: [
                            {
                                buttonType: 'submit',
                                buttonText: 'Add Customer',
                                isVisible: 'true',
                                isButtonCallToAction: 'true'
                            }
                        ]
                    },
                    updateForm: {
                        name: 'UpdateCustomer',
                        titleText: 'Update Customer',
                        targetChildObject: 'Customer',
                        isAuthorizationRequired: 'true',
                        objectWorkflowParam: [
                            {
                                name: 'CustomerID',
                                sqlServerDBDataType: 'int',
                                isVisible: 'false',
                                isRequired: 'true'
                            },
                            {
                                name: 'FirstName',
                                sqlServerDBDataType: 'nvarchar',
                                sqlServerDBDataTypeSize: '100',
                                labelText: 'First Name',
                                isVisible: 'true',
                                isRequired: 'true'
                            }
                        ],
                        objectWorkflowButton: [
                            {
                                buttonType: 'submit',
                                buttonText: 'Update',
                                isVisible: 'true',
                                isButtonCallToAction: 'true'
                            },
                            {
                                buttonType: 'cancel',
                                buttonText: 'Cancel',
                                isVisible: 'true'
                            }
                        ]
                    },
                    deleteForm: {
                        name: 'DeleteCustomer',
                        titleText: 'Delete Customer',
                        targetChildObject: 'Customer',
                        isObjectDelete: 'true',
                        isAuthorizationRequired: 'true',
                        roleRequired: 'Manager',
                        objectWorkflowParam: [
                            {
                                name: 'CustomerID',
                                sqlServerDBDataType: 'int',
                                isVisible: 'false',
                                isRequired: 'true'
                            }
                        ],
                        objectWorkflowButton: [
                            {
                                buttonType: 'submit',
                                buttonText: 'Delete',
                                isVisible: 'true',
                                isButtonCallToAction: 'true'
                            }
                        ],
                        objectWorkflowOutputVar: [
                            {
                                name: 'SuccessMessage',
                                sqlServerDBDataType: 'nvarchar',
                                labelText: 'Success Message',
                                isVisible: 'true',
                                isHeaderText: 'true'
                            }
                        ]
                    },
                    loginForm: {
                        name: 'Login',
                        titleText: 'Login',
                        isLoginPage: 'true',
                        isAuthorizationRequired: 'false',
                        objectWorkflowParam: [
                            {
                                name: 'Username',
                                sqlServerDBDataType: 'nvarchar',
                                sqlServerDBDataTypeSize: '100',
                                labelText: 'Username',
                                isVisible: 'true',
                                isRequired: 'true'
                            },
                            {
                                name: 'Password',
                                sqlServerDBDataType: 'nvarchar',
                                sqlServerDBDataTypeSize: '100',
                                labelText: 'Password',
                                isVisible: 'true',
                                isRequired: 'true',
                                isSecured: 'true'
                            }
                        ],
                        objectWorkflowButton: [
                            {
                                buttonType: 'submit',
                                buttonText: 'Login',
                                isVisible: 'true',
                                isButtonCallToAction: 'true'
                            }
                        ]
                    }
                },
                notes: [
                    'Forms (objectWorkflow) represent user interface forms for data operations',
                    'Each form belongs to a data object and operates on that object or its children',
                    'Form names typically follow the pattern: Action + Entity (AddCustomer, UpdateOrder)',
                    'All boolean flags must be string "true" or "false", not boolean values',
                    'objectWorkflowParam array contains input controls (form fields)',
                    'objectWorkflowButton array contains form buttons (submit, cancel, etc.)',
                    'objectWorkflowOutputVar array contains result displays after submission',
                    'targetChildObject specifies which data object is being operated on',
                    'roleRequired controls access based on user roles from the Role lookup object',
                    'isObjectDelete="true" indicates this is a delete operation form',
                    'initObjectWorkflowName links to a page initialization flow',
                    'Foreign key parameters (isFK="true") should specify fKObjectName',
                    'Lookup foreign keys (isFKLookup="true") reference lookup objects (isLookup="true")',
                    'Forms can have special purposes: login (isLoginPage), logout (isLogoutPage)',
                    'DynaFlow forms (isDynaFlow="true") are workflow-based forms',
                    'File upload fields use isFileUpload="true"',
                    'Credit card entry fields use isCreditCardEntry="true"',
                    'Address autocomplete uses isAutoCompleteAddressSource and related properties'
                ]
            },
            note: 'This schema defines the complete structure of forms (objectWorkflow) in the AppDNA model'
        };
    }

    /**
     * Gets a specific form by name from an owner object
     * Tool name: get_form (following MCP snake_case convention)
     * @param parameters Object containing form_name (required) and owner_object_name (optional)
     * @returns Complete form object with all arrays (params, buttons, output vars) and element counts
     */
    public async get_form(parameters?: any): Promise<any> {
        const { owner_object_name, form_name } = parameters || {};

        // Validate required parameters
        const validationErrors: string[] = [];
        
        if (!form_name) {
            validationErrors.push('form_name is required');
        }

        if (validationErrors.length > 0) {
            return {
                success: false,
                error: 'Validation failed',
                validationErrors: validationErrors,
                note: 'form_name is required (case-sensitive). owner_object_name is optional - if not provided, all objects will be searched.'
            };
        }

        try {
            let endpoint: string;
            let forms: any[];
            
            if (owner_object_name) {
                // If owner specified, fetch forms filtered by both owner and form name
                endpoint = `/api/forms?owner_object_name=${encodeURIComponent(owner_object_name)}&form_name=${encodeURIComponent(form_name)}`;
            } else {
                // If owner not specified, fetch forms filtered by form name only
                endpoint = `/api/forms?form_name=${encodeURIComponent(form_name)}`;
            }
            
            forms = await this.fetchFromBridge(endpoint);
            
            // Check if we found the form
            if (!forms || forms.length === 0) {
                if (owner_object_name) {
                    return {
                        success: false,
                        error: `Form "${form_name}" not found in owner object "${owner_object_name}"`,
                        note: 'Form name and owner object name matching is case-insensitive. Use list_pages with page_type="Form" to see available forms.',
                        validationErrors: [`Form "${form_name}" does not exist in owner object "${owner_object_name}"`]
                    };
                } else {
                    return {
                        success: false,
                        error: `Form "${form_name}" not found in any object`,
                        note: 'Form name matching is case-insensitive. Use list_pages with page_type="Form" to see available forms.',
                        validationErrors: [`Form "${form_name}" does not exist in the model`]
                    };
                }
            }
            
            // Get the first (and should be only) form from results
            const form = forms[0];
            const ownerObjectName = form._ownerObjectName;
            
            // Remove the temporary _ownerObjectName property
            delete form._ownerObjectName;

            // Calculate element counts
            const paramCount = form.objectWorkflowParam ? form.objectWorkflowParam.length : 0;
            const buttonCount = form.objectWorkflowButton ? form.objectWorkflowButton.length : 0;
            const outputVarCount = form.objectWorkflowOutputVar ? form.objectWorkflowOutputVar.length : 0;
            const totalElements = paramCount + buttonCount + outputVarCount;

            // Filter out hidden properties from the form object
            const filteredForm = this.filterHiddenFormProperties(form);

            return {
                success: true,
                form: filteredForm,
                owner_object_name: ownerObjectName,
                element_counts: {
                    paramCount: paramCount,
                    buttonCount: buttonCount,
                    outputVarCount: outputVarCount,
                    totalElements: totalElements
                },
                note: `Form "${form_name}" retrieved successfully from owner object "${ownerObjectName}". ` +
                      `Contains ${paramCount} parameter(s), ${buttonCount} button(s), and ${outputVarCount} output variable(s).`
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not retrieve form: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required to retrieve forms. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Filters out hidden properties from a form object
     * These properties are hidden in the UI and should not be returned by the API
     * @param form The form object to filter
     * @returns Filtered form object without hidden properties
     */
    private filterHiddenFormProperties(form: any): any {
        const hiddenProperties = [
            'isIgnoredInDocumentation',
            'formFooterImageURL',
            'footerImageURL',
            'headerImageURL',
            'isCreditCardEntryUsed',
            'isDynaFlow',
            'isDynaFlowTask',
            'isCustomPageViewUsed',
            'isImpersonationPage',
            'isExposedInBusinessObject'
        ];

        // Create a shallow copy and remove hidden properties
        const filtered = { ...form };
        hiddenProperties.forEach(prop => {
            delete filtered[prop];
        });

        return filtered;
    }

    /**
     * Helper method to fetch data from the HTTP bridge
     * @param endpoint API endpoint to fetch from
     * @returns Parsed JSON response
     */
    private async fetchFromBridge(endpoint: string): Promise<any> {
        const http = await import('http');
        
        return new Promise((resolve, reject) => {
            const options = {
                hostname: 'localhost',
                port: 3001,
                path: endpoint,
                method: 'GET',
                headers: {
                    'Content-Type': 'application/json'
                }
            };

            const req = http.request(options, (res) => {
                let data = '';

                res.on('data', (chunk) => {
                    data += chunk;
                });

                res.on('end', () => {
                    try {
                        const parsedData = JSON.parse(data);
                        resolve(parsedData);
                    } catch (error) {
                        reject(new Error(`Failed to parse response: ${error instanceof Error ? error.message : 'Unknown error'}`));
                    }
                });
            });

            req.on('error', (error) => {
                reject(new Error(`Bridge connection failed: ${error.message}`));
            });

            req.end();
        });
    }

    /**
     * Suggests form name and title based on context
     * Tool name: suggest_form_name_and_title
     * @param parameters - Context for suggestion (owner, role, action, target)
     * @returns Suggested form name (PascalCase) and title (human-readable)
     */
    public async suggest_form_name_and_title(parameters: {
        owner_object_name: string;
        role_required?: string;
        action?: string;
        target_child_object?: string;
    }): Promise<any> {
        const { owner_object_name, role_required, action, target_child_object } = parameters;

        try {
            // Validate owner object exists
            const endpoint = `/api/data-objects`;
            const allObjects = await this.fetchFromBridge(endpoint);
            
            const ownerObject = allObjects.find((obj: any) => obj.name === owner_object_name);
            if (!ownerObject) {
                return {
                    success: false,
                    error: `Owner object "${owner_object_name}" not found`,
                    note: 'Owner object name must match exactly (case-sensitive). Use list_data_object_summary to see available objects.',
                    validationErrors: [`Owner object "${owner_object_name}" does not exist in the model`]
                };
            }

            // Validate role_required exists if provided
            if (role_required) {
                try {
                    const roles = await this.fetchFromBridge('/api/roles');
                    const roleExists = roles.some((role: any) => role.name === role_required);
                    if (!roleExists) {
                        return {
                            success: false,
                            error: `Role "${role_required}" not found`,
                            note: 'Role must match exactly (case-sensitive). Use list_roles to see available roles.',
                            validationErrors: [`Role "${role_required}" does not exist in the Role lookup object`]
                        };
                    }
                } catch (error) {
                    return {
                        success: false,
                        error: 'Could not validate role',
                        note: 'Unable to fetch roles from the model. The Role lookup object may not exist or the bridge connection failed.',
                        validationErrors: ['Failed to validate role_required parameter']
                    };
                }
            }

            // Validate target_child_object exists if provided
            if (target_child_object) {
                const targetObject = allObjects.find((obj: any) => obj.name === target_child_object);
                if (!targetObject) {
                    return {
                        success: false,
                        error: `Target child object "${target_child_object}" not found`,
                        note: 'Target child object name must match exactly (case-sensitive). Use list_data_object_summary to see available objects.',
                        validationErrors: [`Target child object "${target_child_object}" does not exist in the model`]
                    };
                }
            }

            // Build base form name (PascalCase)
            let baseFormName = owner_object_name;
            if (role_required) {
                baseFormName += role_required;
            }
            const actionPart = action || (target_child_object ? 'Add' : '');
            if (actionPart) {
                baseFormName += actionPart;
            }
            if (target_child_object) {
                baseFormName += target_child_object;
            }

            // Check for duplicates and append numeric suffix if needed
            const existingFormNames: string[] = [];
            for (const obj of allObjects) {
                if (obj.objectWorkflow && Array.isArray(obj.objectWorkflow)) {
                    for (const workflow of obj.objectWorkflow) {
                        if (workflow.name) {
                            existingFormNames.push(workflow.name.toLowerCase());
                        }
                    }
                }
            }

            let formName = baseFormName;
            let suffix = 1;
            while (existingFormNames.includes(formName.toLowerCase())) {
                // Append numeric suffix to the action part
                if (actionPart) {
                    formName = owner_object_name;
                    if (role_required) {
                        formName += role_required;
                    }
                    formName += actionPart + suffix;
                    if (target_child_object) {
                        formName += target_child_object;
                    }
                } else {
                    // If no action part, append to the entire name
                    formName = baseFormName + suffix;
                }
                suffix++;
            }

            // Build suggested title (human-readable with spaces)
            const ownerReadable = this.convertToHumanReadable(owner_object_name);
            const targetReadable = target_child_object ? this.convertToHumanReadable(target_child_object) : '';
            const actionReadable = action ? this.convertToHumanReadable(action) : (target_child_object ? 'Add' : '');

            let formTitle = '';
            if (actionReadable) {
                formTitle = actionReadable + ' ';
                // Use target object if creating new instance, otherwise use owner object
                if (targetReadable) {
                    formTitle += targetReadable;
                } else {
                    formTitle += ownerReadable;
                }
            } else {
                // If no action, just use the object name
                formTitle = targetReadable || ownerReadable;
            }

            // Add numeric suffix to title if it was added to the name
            if (suffix > 1) {
                formTitle += ' ' + (suffix - 1);
            }

            return {
                success: true,
                suggestions: {
                    form_name: formName,
                    title_text: formTitle
                },
                context: {
                    owner_object_name: owner_object_name,
                    role_required: role_required || null,
                    action: action || null,
                    target_child_object: target_child_object || null
                },
                note: formName !== baseFormName 
                    ? `Suggested names follow PascalCase convention. A numeric suffix was added to "${baseFormName}" because that form name already exists.`
                    : 'Suggested names follow PascalCase convention. You can modify these suggestions before creating the form.'
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not generate suggestions: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Creates a new form (objectWorkflow) in the specified owner data object
     * Tool name: create_form
     * @param parameters - Form creation parameters
     * @returns Success status with created form details or validation errors
     */
    public async create_form(parameters: {
        owner_object_name: string;
        form_name: string;
        title_text: string;
        role_required?: string;
        target_child_object?: string;
    }): Promise<any> {
        const { owner_object_name, form_name, title_text, role_required, target_child_object } = parameters;

        // Validation array
        const validationErrors: string[] = [];

        try {
            // Validate form_name format (PascalCase)
            const namePattern = /^[A-Z][a-zA-Z0-9]*$/;
            if (!form_name || form_name.trim() === '') {
                validationErrors.push('Form name is required and cannot be empty');
            } else if (!namePattern.test(form_name)) {
                validationErrors.push('Form name must be in PascalCase format (start with uppercase letter, only letters and numbers allowed)');
            }

            // Validate title_text
            if (!title_text || title_text.trim() === '') {
                validationErrors.push('Title text is required and cannot be empty');
            } else if (title_text.length > 100) {
                validationErrors.push('Title text cannot exceed 100 characters');
            }

            // If validation errors at this point, return early
            if (validationErrors.length > 0) {
                return {
                    success: false,
                    error: 'Validation failed',
                    validationErrors: validationErrors,
                    note: 'Please fix the validation errors and try again.'
                };
            }

            // Fetch all objects to validate owner and check for duplicates
            const endpoint = `/api/data-objects`;
            const allObjects = await this.fetchFromBridge(endpoint);

            // Validate owner object exists (case-sensitive exact match)
            const ownerObject = allObjects.find((obj: any) => obj.name === owner_object_name);
            if (!ownerObject) {
                validationErrors.push(`Owner object "${owner_object_name}" not found (case-sensitive match required)`);
                return {
                    success: false,
                    error: `Owner object "${owner_object_name}" not found`,
                    validationErrors: validationErrors,
                    note: 'Owner object name must match exactly (case-sensitive). Use list_data_object_summary to see available objects.'
                };
            }

            // Validate target_child_object if provided (case-sensitive exact match)
            if (target_child_object) {
                const targetObject = allObjects.find((obj: any) => obj.name === target_child_object);
                if (!targetObject) {
                    validationErrors.push(`Target child object "${target_child_object}" not found (case-sensitive match required)`);
                    return {
                        success: false,
                        error: `Target child object "${target_child_object}" not found`,
                        validationErrors: validationErrors,
                        note: 'Target child object name must match exactly (case-sensitive). Use list_data_object_summary to see available objects.'
                    };
                }
            }

            // Validate role_required if provided (case-sensitive exact match)
            if (role_required) {
                try {
                    const roles = await this.fetchFromBridge('/api/roles');
                    const roleExists = roles.some((role: any) => role.name === role_required);
                    if (!roleExists) {
                        validationErrors.push(`Role "${role_required}" not found in the Role lookup object`);
                        return {
                            success: false,
                            error: `Role "${role_required}" not found`,
                            validationErrors: validationErrors,
                            note: 'Role must match exactly (case-sensitive). Use list_roles to see available roles.'
                        };
                    }
                } catch (error) {
                    validationErrors.push('Failed to validate role_required parameter');
                    return {
                        success: false,
                        error: 'Could not validate role',
                        validationErrors: validationErrors,
                        note: 'Unable to fetch roles from the model. The Role lookup object may not exist or the bridge connection failed.'
                    };
                }
            }

            // Check for duplicate form names (case-insensitive across all objects)
            const formNameLower = form_name.toLowerCase();
            for (const obj of allObjects) {
                if (obj.objectWorkflow && Array.isArray(obj.objectWorkflow)) {
                    const duplicate = obj.objectWorkflow.find((wf: any) => 
                        wf.name && wf.name.toLowerCase() === formNameLower
                    );
                    if (duplicate) {
                        validationErrors.push(`Form name "${form_name}" already exists in object "${obj.name}" (case-insensitive check)`);
                        return {
                            success: false,
                            error: `Form name "${form_name}" already exists`,
                            validationErrors: validationErrors,
                            note: 'Form names must be unique across all data objects (case-insensitive). Use a different name.'
                        };
                    }
                }
            }

            // Create the new form object
            const newForm: any = {
                name: form_name,
                titleText: title_text,
                isPage: "true",
                objectWorkflowButton: [
                    {
                        buttonText: "OK",
                        buttonType: "submit",
                        isVisible: "true"
                    },
                    {
                        buttonText: "Cancel",
                        buttonType: "cancel",
                        isVisible: "true"
                    }
                ]
            };

            // Add optional properties based on parameters
            if (role_required) {
                newForm.isAuthorizationRequired = "true";
                newForm.roleRequired = role_required;
                newForm.layoutName = role_required + "Layout";
            } else {
                newForm.isAuthorizationRequired = "false";
            }

            if (target_child_object) {
                newForm.targetChildObject = target_child_object;
            }

            // Create page init flow
            const pageInitFlowName = form_name + "InitObjWF";
            newForm.initObjectWorkflowName = pageInitFlowName;

            const newPageInitFlow = {
                name: pageInitFlowName,
                titleText: title_text + " Page Init",
                objectWorkflowOutputVar: []
            };

            // Add form and page init flow to owner object via HTTP bridge POST
            const createEndpoint = `/api/create-form`;
            const postData = {
                ownerObjectName: owner_object_name,
                form: newForm,
                pageInitFlow: newPageInitFlow
            };

            // Use HTTP POST to create the form
            const http = await import('http');
            const result = await new Promise((resolve, reject) => {
                const postDataString = JSON.stringify(postData);
                const options = {
                    hostname: 'localhost',
                    port: 3001,
                    path: createEndpoint,
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Content-Length': Buffer.byteLength(postDataString)
                    }
                };

                const req = http.request(options, (res) => {
                    let data = '';

                    res.on('data', (chunk) => {
                        data += chunk;
                    });

                    res.on('end', () => {
                        try {
                            const parsedData = JSON.parse(data);
                            resolve(parsedData);
                        } catch (error) {
                            reject(new Error(`Failed to parse response: ${error instanceof Error ? error.message : 'Unknown error'}`));
                        }
                    });
                });

                req.on('error', (error) => {
                    reject(new Error(`Bridge connection failed: ${error.message}`));
                });

                req.write(postDataString);
                req.end();
            });

            // Filter hidden properties from returned form
            const filteredForm = this.filterHiddenFormProperties(newForm);

            return {
                success: true,
                form: filteredForm,
                page_init_flow: newPageInitFlow,
                owner_object_name: owner_object_name,
                message: `Form "${form_name}" and page init flow "${pageInitFlowName}" created successfully`,
                note: 'Form has been added to the model with default OK and Cancel buttons. Use add_form_param to add input parameters and add_form_button to add custom buttons.'
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not create form: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required to create forms. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Update an existing form's properties
     * @param form_name - Name of the form to update (case-sensitive, exact match required)
     * @param updates - Object containing properties to update (at least one required)
     * @returns Result object with success status
     */
    async update_form(
        form_name: string,
        updates: {
            titleText?: string;
            isInitObjWFSubscribedToParams?: 'true' | 'false';
            isObjectDelete?: 'true' | 'false';
            layoutName?: string;
            introText?: string;
            formTitleText?: string;
            formIntroText?: string;
            formFooterText?: string;
            codeDescription?: string;
            isAutoSubmit?: 'true' | 'false';
            isHeaderVisible?: 'true' | 'false';
            isAuthorizationRequired?: 'true' | 'false';
            isLoginPage?: 'true' | 'false';
            isLogoutPage?: 'true' | 'false';
            isCaptchaVisible?: 'true' | 'false';
            isCustomLogicOverwritten?: 'true' | 'false';
        }
    ): Promise<{ success: boolean; form?: any; owner_object_name?: string; message?: string; error?: string; note?: string }> {
        try {
            // Validate at least one property to update
            const updateKeys = Object.keys(updates);
            if (updateKeys.length === 0) {
                return {
                    success: false,
                    error: 'At least one property to update must be provided'
                };
            }

            // Call bridge API to update form
            const http = await import('http');
            const postData = {
                form_name,
                updates: updates
            };

            const postDataString = JSON.stringify(postData);

            const updatedForm: any = await new Promise((resolve, reject) => {
                const req = http.request(
                    {
                        hostname: 'localhost',
                        port: 3001,
                        path: '/api/update-form',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Content-Length': Buffer.byteLength(postDataString)
                        }
                    },
                    (res) => {
                        let data = '';
                        res.on('data', (chunk) => {
                            data += chunk;
                        });
                        res.on('end', () => {
                            if (res.statusCode === 200) {
                                resolve(JSON.parse(data));
                            } else {
                                reject(new Error(data || `HTTP ${res.statusCode}`));
                            }
                        });
                    }
                );

                req.on('error', (error) => {
                    reject(error);
                });

                req.write(postDataString);
                req.end();
            });

            if (!updatedForm.success) {
                return {
                    success: false,
                    error: updatedForm.error || 'Failed to update form'
                };
            }

            // Filter hidden properties from returned form
            const filteredForm = this.filterHiddenFormProperties(updatedForm.form);

            return {
                success: true,
                form: filteredForm,
                owner_object_name: updatedForm.owner_object_name,
                message: `Form "${form_name}" updated successfully`,
                note: 'Form properties have been updated. The model has unsaved changes.'
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not update form: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required to update forms. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Add a new parameter (input control) to an existing form
     * @param form_name - Name of the form to add the parameter to (case-sensitive, exact match required)
     * @param param - The parameter object to add
     * @returns Result object with success status
     */
    async add_form_param(
        form_name: string,
        param: {
            name: string;
            sqlServerDBDataType?: string;
            sqlServerDBDataTypeSize?: string;
            labelText?: string;
            infoToolTipText?: string;
            codeDescription?: string;
            defaultValue?: string;
            isVisible?: 'true' | 'false';
            isRequired?: 'true' | 'false';
            requiredErrorText?: string;
            isSecured?: 'true' | 'false';
            isFK?: 'true' | 'false';
            fKObjectName?: string;
            fKObjectQueryName?: string;
            isFKLookup?: 'true' | 'false';
            isFKList?: 'true' | 'false';
            isFKListInactiveIncluded?: 'true' | 'false';
            isFKListUnknownOptionRemoved?: 'true' | 'false';
            fKListOrderBy?: string;
            isFKListOptionRecommended?: 'true' | 'false';
            isFKListSearchable?: 'true' | 'false';
            FKListRecommendedOption?: string;
            isRadioButtonList?: 'true' | 'false';
            isFileUpload?: 'true' | 'false';
            isCreditCardEntry?: 'true' | 'false';
            isTimeZoneDetermined?: 'true' | 'false';
            isAutoCompleteAddressSource?: 'true' | 'false';
            autoCompleteAddressSourceName?: string;
            autoCompleteAddressTargetType?: string;
            detailsText?: string;
            validationRuleRegExMatchRequired?: string;
            validationRuleRegExMatchRequiredErrorText?: string;
            isIgnored?: 'true' | 'false';
            sourceObjectName?: string;
            sourcePropertyName?: string;
        }
    ): Promise<{ success: boolean; param?: any; form_name?: string; owner_object_name?: string; message?: string; error?: string; note?: string }> {
        try {
            // Validate required parameter name
            if (!param.name) {
                return {
                    success: false,
                    error: 'Parameter name is required'
                };
            }

            // Call bridge API to add form param
            const http = await import('http');
            const postData = {
                form_name,
                param: param
            };

            const postDataString = JSON.stringify(postData);

            const result: any = await new Promise((resolve, reject) => {
                const req = http.request(
                    {
                        hostname: 'localhost',
                        port: 3001,
                        path: '/api/add-form-param',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Content-Length': Buffer.byteLength(postDataString)
                        }
                    },
                    (res) => {
                        let data = '';
                        res.on('data', (chunk) => {
                            data += chunk;
                        });
                        res.on('end', () => {
                            if (res.statusCode === 200) {
                                resolve(JSON.parse(data));
                            } else {
                                reject(new Error(data || `HTTP ${res.statusCode}`));
                            }
                        });
                    }
                );

                req.on('error', (error) => {
                    reject(error);
                });

                req.write(postDataString);
                req.end();
            });

            if (!result.success) {
                return {
                    success: false,
                    error: result.error || 'Failed to add form parameter'
                };
            }

            return {
                success: true,
                param: result.param,
                form_name: form_name,
                owner_object_name: result.owner_object_name,
                message: `Parameter "${param.name}" added to form "${form_name}" successfully`,
                note: 'Form parameter has been added. The model has unsaved changes.'
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not add form parameter: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required to add form parameters. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Update an existing parameter (input control) in a form
     * @param form_name - Name of the form containing the parameter (case-sensitive, exact match required)
     * @param param_name - Name of the parameter to update (case-sensitive, exact match required)
     * @param updates - Object containing properties to update (at least one required)
     * @returns Result object with success status
     */
    async update_form_param(
        form_name: string,
        param_name: string,
        updates: {
            sqlServerDBDataType?: string;
            sqlServerDBDataTypeSize?: string;
            labelText?: string;
            infoToolTipText?: string;
            codeDescription?: string;
            defaultValue?: string;
            isVisible?: 'true' | 'false';
            isRequired?: 'true' | 'false';
            requiredErrorText?: string;
            isSecured?: 'true' | 'false';
            isFK?: 'true' | 'false';
            fKObjectName?: string;
            fKObjectQueryName?: string;
            isFKLookup?: 'true' | 'false';
            isFKList?: 'true' | 'false';
            isFKListInactiveIncluded?: 'true' | 'false';
            isFKListUnknownOptionRemoved?: 'true' | 'false';
            fKListOrderBy?: string;
            isFKListOptionRecommended?: 'true' | 'false';
            isFKListSearchable?: 'true' | 'false';
            FKListRecommendedOption?: string;
            isRadioButtonList?: 'true' | 'false';
            isFileUpload?: 'true' | 'false';
            isCreditCardEntry?: 'true' | 'false';
            isTimeZoneDetermined?: 'true' | 'false';
            isAutoCompleteAddressSource?: 'true' | 'false';
            autoCompleteAddressSourceName?: string;
            autoCompleteAddressTargetType?: string;
            detailsText?: string;
            validationRuleRegExMatchRequired?: string;
            validationRuleRegExMatchRequiredErrorText?: string;
            isIgnored?: 'true' | 'false';
            sourceObjectName?: string;
            sourcePropertyName?: string;
        }
    ): Promise<{ success: boolean; param?: any; form_name?: string; owner_object_name?: string; message?: string; error?: string; note?: string }> {
        try {
            // Validate at least one property to update
            const updateKeys = Object.keys(updates);
            if (updateKeys.length === 0) {
                return {
                    success: false,
                    error: 'At least one property to update must be provided'
                };
            }

            // Call bridge API to update form param
            const http = await import('http');
            const postData = {
                form_name,
                param_name,
                updates: updates
            };

            const postDataString = JSON.stringify(postData);

            const result: any = await new Promise((resolve, reject) => {
                const req = http.request(
                    {
                        hostname: 'localhost',
                        port: 3001,
                        path: '/api/update-form-param',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Content-Length': Buffer.byteLength(postDataString)
                        }
                    },
                    (res) => {
                        let data = '';
                        res.on('data', (chunk) => {
                            data += chunk;
                        });
                        res.on('end', () => {
                            if (res.statusCode === 200) {
                                resolve(JSON.parse(data));
                            } else {
                                reject(new Error(data || `HTTP ${res.statusCode}`));
                            }
                        });
                    }
                );

                req.on('error', (error) => {
                    reject(error);
                });

                req.write(postDataString);
                req.end();
            });

            if (!result.success) {
                return {
                    success: false,
                    error: result.error || 'Failed to update form parameter'
                };
            }

            return {
                success: true,
                param: result.param,
                form_name: form_name,
                owner_object_name: result.owner_object_name,
                message: `Parameter "${param_name}" in form "${form_name}" updated successfully`,
                note: 'Form parameter has been updated. The model has unsaved changes.'
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not update form parameter: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required to update form parameters. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Add a new button to an existing form
     * @param form_name - Name of the form to add the button to (case-sensitive, exact match required)
     * @param button - The button object to add
     * @returns Result object with success status
     */
    async add_form_button(
        form_name: string,
        button: {
            buttonText: string;
            buttonType?: string;
            isVisible?: 'true' | 'false';
            conditionalVisiblePropertyName?: string;
            destinationContextObjectName?: string;
            destinationTargetName?: string;
            introText?: string;
            isButtonCallToAction?: 'true' | 'false';
            accessKey?: string;
            isAccessKeyAvailable?: 'true' | 'false';
        }
    ): Promise<{ success: boolean; button?: any; form_name?: string; owner_object_name?: string; message?: string; error?: string; note?: string }> {
        try {
            // Validate required button text
            if (!button.buttonText) {
                return {
                    success: false,
                    error: 'Button text is required'
                };
            }

            // Call bridge API to add form button
            const http = await import('http');
            const postData = {
                form_name,
                button: button
            };

            const postDataString = JSON.stringify(postData);

            const result: any = await new Promise((resolve, reject) => {
                const req = http.request(
                    {
                        hostname: 'localhost',
                        port: 3001,
                        path: '/api/add-form-button',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Content-Length': Buffer.byteLength(postDataString)
                        }
                    },
                    (res) => {
                        let data = '';
                        res.on('data', (chunk) => {
                            data += chunk;
                        });
                        res.on('end', () => {
                            if (res.statusCode === 200) {
                                resolve(JSON.parse(data));
                            } else {
                                reject(new Error(data || `HTTP ${res.statusCode}`));
                            }
                        });
                    }
                );

                req.on('error', (error) => {
                    reject(error);
                });

                req.write(postDataString);
                req.end();
            });

            if (!result.success) {
                return {
                    success: false,
                    error: result.error || 'Failed to add form button'
                };
            }

            return {
                success: true,
                button: result.button,
                form_name: form_name,
                owner_object_name: result.owner_object_name,
                message: `Button "${button.buttonText}" added to form "${form_name}" successfully`,
                note: 'Form button has been added. The model has unsaved changes.'
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not add form button: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required to add form buttons. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Update an existing button in a form
     * @param form_name - Name of the form containing the button (case-sensitive, exact match required)
     * @param button_text - Text of the button to update (case-sensitive, exact match required)
     * @param updates - Object containing properties to update (at least one required)
     * @returns Result object with success status
     */
    async update_form_button(
        form_name: string,
        button_text: string,
        updates: {
            buttonType?: string;
            buttonText?: string;
            isVisible?: 'true' | 'false';
            conditionalVisiblePropertyName?: string;
            destinationContextObjectName?: string;
            destinationTargetName?: string;
            introText?: string;
            isButtonCallToAction?: 'true' | 'false';
            accessKey?: string;
            isAccessKeyAvailable?: 'true' | 'false';
        }
    ): Promise<{ success: boolean; button?: any; form_name?: string; owner_object_name?: string; message?: string; error?: string; note?: string }> {
        try {
            // Validate at least one property to update
            const updateKeys = Object.keys(updates);
            if (updateKeys.length === 0) {
                return {
                    success: false,
                    error: 'At least one property to update must be provided'
                };
            }

            // Call bridge API to update form button
            const http = await import('http');
            const postData = {
                form_name,
                button_text,
                updates: updates
            };

            const postDataString = JSON.stringify(postData);

            const result: any = await new Promise((resolve, reject) => {
                const req = http.request(
                    {
                        hostname: 'localhost',
                        port: 3001,
                        path: '/api/update-form-button',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Content-Length': Buffer.byteLength(postDataString)
                        }
                    },
                    (res) => {
                        let data = '';
                        res.on('data', (chunk) => {
                            data += chunk;
                        });
                        res.on('end', () => {
                            if (res.statusCode === 200) {
                                resolve(JSON.parse(data));
                            } else {
                                reject(new Error(data || `HTTP ${res.statusCode}`));
                            }
                        });
                    }
                );

                req.on('error', (error) => {
                    reject(error);
                });

                req.write(postDataString);
                req.end();
            });

            if (!result.success) {
                return {
                    success: false,
                    error: result.error || 'Failed to update form button'
                };
            }

            return {
                success: true,
                button: result.button,
                form_name: form_name,
                owner_object_name: result.owner_object_name,
                message: `Button "${button_text}" in form "${form_name}" updated successfully`,
                note: 'Form button has been updated. The model has unsaved changes.'
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not update form button: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required to update form buttons. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Add a new output variable to an existing form
     * @param form_name - Name of the form (case-sensitive exact match)
     * @param output_var - Output variable object with name (required) and optional properties
     * @returns Result with success status and output variable details
     */
    async add_form_output_var(
        form_name: string,
        output_var: {
            name: string;
            sqlServerDBDataType?: string;
            sqlServerDBDataTypeSize?: string;
            labelText?: string;
            buttonText?: string;
            buttonNavURL?: string;
            isLabelVisible?: string;
            defaultValue?: string;
            isLink?: string;
            isAutoRedirectURL?: string;
            buttonObjectWFName?: string;
            conditionalVisiblePropertyName?: string;
            isVisible?: string;
            isFK?: string;
            fKObjectName?: string;
            isFKLookup?: string;
            isHeaderText?: string;
            isIgnored?: string;
            sourceObjectName?: string;
            sourcePropertyName?: string;
        }
    ): Promise<any> {
        if (!output_var.name) {
            return {
                success: false,
                error: 'Output variable name is required'
            };
        }

        try {
            const postData = {
                form_name,
                output_var: output_var
            };

            const http = await import('http');
            const result = await new Promise((resolve, reject) => {
                const postDataString = JSON.stringify(postData);
                const options = {
                    hostname: 'localhost',
                    port: 3001,
                    path: '/api/add-form-output-var',
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Content-Length': Buffer.byteLength(postDataString)
                    }
                };

                const req = http.request(options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => { data += chunk; });
                    res.on('end', () => {
                        try {
                            resolve(JSON.parse(data));
                        } catch (e) {
                            reject(new Error('Failed to parse response'));
                        }
                    });
                });

                req.on('error', reject);
                req.write(postDataString);
                req.end();
            });

            const response = result as any;

            if (response.success) {
                return {
                    success: true,
                    output_var: response.output_var,
                    form_name: form_name,
                    owner_object_name: response.owner_object_name,
                    message: `Output variable "${output_var.name}" added to form "${form_name}" successfully`
                };
            } else {
                return {
                    success: false,
                    error: response.error || 'Failed to add form output variable'
                };
            }
        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Failed to add form output variable'
            };
        }
    }

    /**
     * Update an existing output variable in a form
     * @param form_name - Name of the form (case-sensitive exact match)
     * @param output_var_name - Name of the output variable to update (case-sensitive exact match)
     * @param updates - Object containing properties to update
     * @returns Result with success status and updated output variable
     */
    async update_form_output_var(
        form_name: string,
        output_var_name: string,
        updates: {
            name?: string;
            sqlServerDBDataType?: string;
            sqlServerDBDataTypeSize?: string;
            labelText?: string;
            buttonText?: string;
            buttonNavURL?: string;
            isLabelVisible?: string;
            defaultValue?: string;
            isLink?: string;
            isAutoRedirectURL?: string;
            buttonObjectWFName?: string;
            conditionalVisiblePropertyName?: string;
            isVisible?: string;
            isFK?: string;
            fKObjectName?: string;
            isFKLookup?: string;
            isHeaderText?: string;
            isIgnored?: string;
            sourceObjectName?: string;
            sourcePropertyName?: string;
        }
    ): Promise<any> {
        if (Object.keys(updates).length === 0) {
            return {
                success: false,
                error: 'At least one property to update is required'
            };
        }

        try {
            const postData = {
                form_name,
                output_var_name,
                updates: updates
            };

            const http = await import('http');
            const result = await new Promise((resolve, reject) => {
                const postDataString = JSON.stringify(postData);
                const options = {
                    hostname: 'localhost',
                    port: 3001,
                    path: '/api/update-form-output-var',
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Content-Length': Buffer.byteLength(postDataString)
                    }
                };

                const req = http.request(options, (res) => {
                    let data = '';
                    res.on('data', (chunk) => { data += chunk; });
                    res.on('end', () => {
                        try {
                            resolve(JSON.parse(data));
                        } catch (e) {
                            reject(new Error('Failed to parse response'));
                        }
                    });
                });

                req.on('error', reject);
                req.write(postDataString);
                req.end();
            });

            const response = result as any;

            if (response.success) {
                return {
                    success: true,
                    output_var: response.output_var,
                    form_name: form_name,
                    owner_object_name: response.owner_object_name,
                    message: `Output variable "${output_var_name}" in form "${form_name}" updated successfully`
                };
            } else {
                return {
                    success: false,
                    error: response.error || 'Failed to update form output variable'
                };
            }
        } catch (error) {
            return {
                success: false,
                error: error instanceof Error ? error.message : 'Failed to update form output variable'
            };
        }
    }

    /**
     * Update an existing form with provided properties (merge/patch operation)
     * This tool updates or adds the specified properties without removing existing ones.
     * For param, outputVar, and button arrays, items are matched by name/buttonText - existing items are updated with provided fields,
     * new items are added, but items not included in the update are preserved.
     * The form name is never changed.
     * @param form_name - Name of the form to update (case-sensitive exact match)
     * @param form - Partial form object containing properties to update/add
     * @returns Result with success status and updated form details
     */
    async update_full_form(
        form_name: string,
        form: {
            titleText?: string;
            initObjectWorkflowName?: string;
            isInitObjWFSubscribedToParams?: 'true' | 'false';
            isExposedInBusinessObject?: 'true' | 'false';
            isObjectDelete?: 'true' | 'false';
            layoutName?: string;
            introText?: string;
            formTitleText?: string;
            formIntroText?: string;
            formFooterText?: string;
            formFooterImageURL?: string;
            codeDescription?: string;
            isAutoSubmit?: 'true' | 'false';
            isHeaderVisible?: 'true' | 'false';
            isPage?: '' | 'true' | 'false';
            isAuthorizationRequired?: 'true' | 'false';
            isLoginPage?: 'true' | 'false';
            isLogoutPage?: 'true' | 'false';
            isImpersonationPage?: 'true' | 'false';
            roleRequired?: string;
            isCaptchaVisible?: 'true' | 'false';
            isCreditCardEntryUsed?: 'true' | 'false';
            headerImageURL?: string;
            footerImageURL?: string;
            isDynaFlow?: 'true' | 'false';
            isDynaFlowTask?: 'true' | 'false';
            isCustomPageViewUsed?: 'true' | 'false';
            isIgnoredInDocumentation?: 'true' | 'false';
            targetChildObject?: string;
            isCustomLogicOverwritten?: 'true' | 'false';
            objectWorkflowParam?: Array<any>;
            objectWorkflowOutputVar?: Array<any>;
            objectWorkflowButton?: Array<any>;
        }
    ): Promise<{ success: boolean; form?: any; owner_object_name?: string; message?: string; error?: string; note?: string; validationErrors?: string[] }> {
        // Validate required parameters
        const validationErrors: string[] = [];
        
        if (!form_name) {
            validationErrors.push('form_name is required');
        }
        
        if (!form || typeof form !== 'object') {
            validationErrors.push('form object is required');
        }
        
        if (validationErrors.length > 0) {
            return {
                success: false,
                error: 'Validation failed',
                validationErrors: validationErrors,
                note: 'form_name is required (case-sensitive). form object must be provided with at least one property to update.'
            };
        }
        
        // Get actual schema for validation
        const schemaResult = await this.get_form_schema();
        const schema = schemaResult.schema;
        
        // Use JSON Schema validation with ajv
        if (schema) {
            try {
                const Ajv = require('ajv');
                const ajv = new Ajv({ allErrors: true, strict: false });
                
                const validate = ajv.compile(schema);
                const valid = validate(form);
                
                if (!valid && validate.errors) {
                    validate.errors.forEach((error: any) => {
                        const path = error.instancePath || error.dataPath || '';
                        const field = path.replace(/^\//, '').replace(/\//g, '.') || 'root';
                        
                        if (error.keyword === 'enum') {
                            validationErrors.push(`${field}: must be one of ${JSON.stringify(error.params.allowedValues)}`);
                        } else if (error.keyword === 'pattern') {
                            validationErrors.push(`${field}: ${error.message} (expected pattern: ${error.params.pattern})`);
                        } else if (error.keyword === 'type') {
                            validationErrors.push(`${field}: must be ${error.params.type}`);
                        } else if (error.keyword === 'required') {
                            validationErrors.push(`${error.params.missingProperty} is required`);
                        } else {
                            validationErrors.push(`${field}: ${error.message}`);
                        }
                    });
                }
            } catch (error) {
                // If schema validation fails, fall back to basic validation
                console.error('Schema validation error:', error);
            }
        }
        
        // Additional business rule validation
        if (form.objectWorkflowParam && Array.isArray(form.objectWorkflowParam)) {
            form.objectWorkflowParam.forEach((param: any, index: number) => {
                // Validate FK requires fKObjectName
                if (param.isFK === 'true' && !param.fKObjectName) {
                    validationErrors.push(`Parameter ${index} (${param.name || index}): fKObjectName is required when isFK is "true"`);
                }
            });
        }
        
        if (validationErrors.length > 0) {
            return {
                success: false,
                error: 'Validation failed',
                validationErrors: validationErrors,
                note: 'Please check the validation errors and ensure all values match the schema requirements from get_form_schema.'
            };
        }
        
        try {
            // Call bridge API to update full form
            const http = await import('http');
            const postData = {
                form_name,
                form: form
            };

            const postDataString = JSON.stringify(postData);

            const result: any = await new Promise((resolve, reject) => {
                const req = http.request(
                    {
                        hostname: 'localhost',
                        port: 3001,
                        path: '/api/update-full-form',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Content-Length': Buffer.byteLength(postDataString)
                        }
                    },
                    (res) => {
                        let data = '';
                        res.on('data', (chunk) => {
                            data += chunk;
                        });
                        res.on('end', () => {
                            if (res.statusCode === 200) {
                                resolve(JSON.parse(data));
                            } else {
                                reject(new Error(data || `HTTP ${res.statusCode}`));
                            }
                        });
                    }
                );

                req.on('error', (error) => {
                    reject(error);
                });

                req.write(postDataString);
                req.end();
            });

            if (!result.success) {
                return {
                    success: false,
                    error: result.error || 'Failed to update full form'
                };
            }

            // Filter hidden properties from returned form
            const filteredForm = this.filterHiddenFormProperties(result.form);

            return {
                success: true,
                form: filteredForm,
                owner_object_name: result.owner_object_name,
                message: `Form "${form_name}" updated successfully with merge/patch operation`,
                note: 'Form properties have been updated or added. Existing properties not in the update were preserved. The model has unsaved changes.'
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not update full form: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required to update forms. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Move a form parameter to a new position in the objectWorkflowParam array
     * @param form_name - Name of the form (case-sensitive exact match)
     * @param param_name - Name of the parameter to move (case-sensitive exact match)
     * @param new_position - New 0-based index position for the parameter
     * @returns Result with success status and position details
     */
    async move_form_param(
        form_name: string,
        param_name: string,
        new_position: number
    ): Promise<any> {
        try {
            // Validate inputs
            if (new_position < 0) {
                return {
                    success: false,
                    error: 'new_position must be 0 or greater'
                };
            }

            // Call bridge API to move form param
            const http = await import('http');
            const postData = {
                form_name,
                param_name,
                new_position
            };

            const postDataString = JSON.stringify(postData);

            const result: any = await new Promise((resolve, reject) => {
                const req = http.request(
                    {
                        hostname: 'localhost',
                        port: 3001,
                        path: '/api/move-form-param',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Content-Length': Buffer.byteLength(postDataString)
                        }
                    },
                    (res) => {
                        let data = '';
                        res.on('data', (chunk) => {
                            data += chunk;
                        });
                        res.on('end', () => {
                            if (res.statusCode === 200) {
                                resolve(JSON.parse(data));
                            } else {
                                reject(new Error(data || `HTTP ${res.statusCode}`));
                            }
                        });
                    }
                );

                req.on('error', (error) => {
                    reject(error);
                });

                req.write(postDataString);
                req.end();
            });

            if (!result.success) {
                return {
                    success: false,
                    error: result.error || 'Failed to move form parameter'
                };
            }

            return {
                success: true,
                form_name: form_name,
                owner_object_name: result.owner_object_name,
                param_name: param_name,
                old_position: result.old_position,
                new_position: new_position,
                param_count: result.param_count,
                message: `Parameter "${param_name}" moved from position ${result.old_position} to position ${new_position}`,
                note: 'Form parameter has been reordered. The model has unsaved changes.'
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not move form parameter: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required to move form parameters. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Move a form button to a new position in the objectWorkflowButton array
     * @param form_name - Name of the form (case-sensitive exact match)
     * @param button_text - Text of the button to move (case-sensitive exact match)
     * @param new_position - New 0-based index position for the button
     * @returns Result with success status and position details
     */
    async move_form_button(
        form_name: string,
        button_text: string,
        new_position: number
    ): Promise<any> {
        try {
            if (new_position < 0) {
                return {
                    success: false,
                    error: 'new_position must be 0 or greater'
                };
            }

            const http = await import('http');
            const postData = { form_name, button_text, new_position };
            const postDataString = JSON.stringify(postData);

            const result: any = await new Promise((resolve, reject) => {
                const req = http.request(
                    {
                        hostname: 'localhost',
                        port: 3001,
                        path: '/api/move-form-button',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Content-Length': Buffer.byteLength(postDataString)
                        }
                    },
                    (res) => {
                        let data = '';
                        res.on('data', (chunk) => { data += chunk; });
                        res.on('end', () => {
                            if (res.statusCode === 200) {
                                resolve(JSON.parse(data));
                            } else {
                                reject(new Error(data || `HTTP ${res.statusCode}`));
                            }
                        });
                    }
                );
                req.on('error', (error) => { reject(error); });
                req.write(postDataString);
                req.end();
            });

            if (!result.success) {
                return { success: false, error: result.error || 'Failed to move form button' };
            }

            return {
                success: true,
                form_name: form_name,
                owner_object_name: result.owner_object_name,
                button_text: button_text,
                old_position: result.old_position,
                new_position: new_position,
                button_count: result.button_count,
                message: `Button "${button_text}" moved from position ${result.old_position} to position ${new_position}`,
                note: 'Form button has been reordered. The model has unsaved changes.'
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not move form button: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Move a form output variable to a new position in the objectWorkflowOutputVar array
     * @param form_name - Name of the form (case-sensitive exact match)
     * @param output_var_name - Name of the output variable to move (case-sensitive exact match)
     * @param new_position - New 0-based index position for the output variable
     * @returns Result with success status and position details
     */
    async move_form_output_var(
        form_name: string,
        output_var_name: string,
        new_position: number
    ): Promise<any> {
        try {
            if (new_position < 0) {
                return {
                    success: false,
                    error: 'new_position must be 0 or greater'
                };
            }

            const http = await import('http');
            const postData = { form_name, output_var_name, new_position };
            const postDataString = JSON.stringify(postData);

            const result: any = await new Promise((resolve, reject) => {
                const req = http.request(
                    {
                        hostname: 'localhost',
                        port: 3001,
                        path: '/api/move-form-output-var',
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Content-Length': Buffer.byteLength(postDataString)
                        }
                    },
                    (res) => {
                        let data = '';
                        res.on('data', (chunk) => { data += chunk; });
                        res.on('end', () => {
                            if (res.statusCode === 200) {
                                resolve(JSON.parse(data));
                            } else {
                                reject(new Error(data || `HTTP ${res.statusCode}`));
                            }
                        });
                    }
                );
                req.on('error', (error) => { reject(error); });
                req.write(postDataString);
                req.end();
            });

            if (!result.success) {
                return { success: false, error: result.error || 'Failed to move form output variable' };
            }

            return {
                success: true,
                form_name: form_name,
                owner_object_name: result.owner_object_name,
                output_var_name: output_var_name,
                old_position: result.old_position,
                new_position: new_position,
                output_var_count: result.output_var_count,
                message: `Output variable "${output_var_name}" moved from position ${result.old_position} to position ${new_position}`,
                note: 'Form output variable has been reordered. The model has unsaved changes.'
            };

        } catch (error) {
            return {
                success: false,
                error: `Could not move form output variable: ${error instanceof Error ? error.message : 'Unknown error'}`,
                note: 'Bridge connection required. Make sure the AppDNA extension is running and a model file is loaded.'
            };
        }
    }

    /**
     * Converts PascalCase to human-readable format with spaces
     * @param text - PascalCase text
     * @returns Human-readable text with spaces
     */
    private convertToHumanReadable(text: string): string {
        if (!text) {
            return '';
        }
        return text.replace(/([A-Z])/g, ' $1').trim();
    }
}
